# 贡献指南 (Contribution Guidelines)

> **【模板文件 - 请勿直接修改】**
>
> 本文件是 CodeCraftAI 核心模板的一部分。为了方便未来无冲突地升级模板，请**不要**直接修改本文件。
>
> 如果你需要添加项目专属的贡献指南或开发规范，请在 `project_docs/` 目录下创建新的 Markdown 文件，并在本文末尾的“项目特定规范”部分添加链接。

欢迎你为 CodeCraftAI 项目贡献代码或文档！本指南旨在帮助每一位成员高效协作，并共同维护项目的长期健康。

## 1. 项目理念

我们不仅仅是在构建一个项目，更是在实践一套高效、透明、可追溯的开发哲学。我们建立的所有规范（Spec、ADR、Git工作流等）都是为了服务于以下核心目标：

*   **清晰优于聪明**: 我们更倾向于清晰、可读的代码和文档，而不是难以理解的“聪明”技巧。
*   **决策可追溯**: 任何重要的技术决策都应该被记录下来，以便未来的我们能够理解当时“为什么”这样做。
*   **自动化保障质量**: 我们相信应该让工具来做重复性的、易错的检查工作，让人类专注于创造性的、有价值的思考。
*   **文档驱动开发**: 我们在编码前思考和写作，确保我们在正确的方向上努力。

## 2. 我们的工具链

为了实现上述理念，我们采用了一套精心挑选的、行业标准的工具链。了解它们的作用将帮助你更好地为项目做贡献。

*   **`pytest`**: Python 的黄金标准测试框架。我们用它来保证代码的正确性和健壮性。
*   **`black`**: “不妥协”的代码格式化工具。它能终结所有关于代码风格的争论，让所有代码看起来都像一个人写的。
*   **`ruff`**: 极速的 Python Linter。它能在瞬间扫描代码，发现从简单语法错误到复杂逻辑缺陷的数百种问题。
*   **`pre-commit`**: Git 钩子管理器。它是我们的自动化质量守卫，在每次你提交代码时，它都会自动运行 `black` 和 `ruff`，确保不符合质量标准的代码无法进入我们的代码库。
*   **`pip-tools`**: 依赖管理工具。我们用它将 `pyproject.toml` 中定义的高级依赖，编译成包含精确版本号的 `requirements.txt` 文件，以确保环境的绝对可复现性。

## 3. 沟通语言

为了方便当前团队的沟通，我们约定所有公开的交流和文档编写均使用 **中文**。这包括 Git 提交信息、Pull Request、代码注释、规范文档等。

*注：随着项目的发展和国际化，未来可能会转为使用英语。*

## 4. Git 工作流规范

我们遵循一个结构化的 Git 工作流，以保持版本历史的清晰和可追溯性。

### 分支命名

所有分支都应从 `main` 分支创建，并遵循 `类型/简短描述` 的格式（示例: `feat/real-time-debugging`, `fix/login-bug`）。详细的 `<类型>` 列表请见下文。

### 提交信息 (Commit Messages)

我们采用 **Conventional Commits** 规范。格式为 `<类型>[可选的作用域]: <描述>`。

**`<类型>`** 必须是以下之一：
*   **feat**: 新功能
*   **fix**: Bug 修复
*   **docs**: 文档变更
*   **style**: 代码风格
*   **refactor**: 代码重构
*   **test**: 增加或修改测试
*   **chore**: 构建过程或辅助工具的变动

## 6. AI的强制性开发工作流

为杜绝低级错误并确保每一行代码都符合最高的质量标准，所有AI开发者**必须**严格遵循以下包含三个阶段、五个步骤的开发工作流。这不仅是一份指南，更是AI行为的核心准则。

### **第一阶段：API与引用验证 (编码前)**

#### **步骤 1：主动探索与临时笔记**
在你编写任何正式代码**之前**，你**必须**对所有即将引用的外部库、内部模块或函数进行主动探索。

1.  **编写探索脚本**: 创建一个临时的探索脚本 (例如, `tmp_explore_api.py`)。
2.  **分析API**: 在脚本中使用 Python 的内建函数 `dir()` 和 `help()` 来系统性地检查目标库的可用 API、函数签名、参数、返回值和文档字符串。
3.  **创建临时笔记**: 将探索得到的关键信息整理成一个临时的 Markdown 笔记文件 (例如, `temp_api_notes.md`)。这份笔记是你后续编码的**唯一真理之源**。

### **第二阶段：编码与即时自检 (编码中)**

#### **步骤 2：依据笔记编码**
你**必须**严格依据你在第一阶段创建的临时笔记进行编码，以确保所有的函数调用和变量引用都是准确无误的。

#### **步骤 3：启动“守护进程”**
在开始编码时，你**必须**在一个单独的终端中启动实时开发助手：
```bash
python .codecraft/scripts/guardian.py
```
这个“守护进程”会在你每次保存文件时，立即在后台为你运行代码检查 (`ruff`, `black`)、静态类型检查 (`mypy`) 和单元测试 (`pytest`)，提供即时的质量反馈。

### **第三阶段：严格的单元测试与最终验证 (编码后，提交前)**

#### **步骤 4：编写全面的单元测试**
对于你所编写的**每一个**新功能或修复，你**必须**为其编写一套全面的单元测试。这套测试**必须**覆盖以下场景：

*   **成功场景 (Happy Path)**: 验证功能在正常输入下按预期工作。
*   **失败场景 (Unhappy Path)**:
    *   **无效输入**: 测试函数在接收到 `None`、空字符串、错误类型或超出范围的数值时的行为。
    *   **边界值**: 测试边缘情况，例如列表为空、数值为0等。
    *   **预期异常**: 测试代码是否能在预期的失败情况下（例如，文件不存在）抛出正确的异常（例如 `FileNotFoundError`）。
*   **模拟 (Mocking)**: 如果你的代码引用了任何外部依赖（文件系统、数据库、网络API等），你**必须**使用 Python 的 `unittest.mock` 库来模拟这些依赖的各种行为（成功、失败、超时、返回空数据等），以确保你的代码能够优雅地处理所有外部情况。

#### **步骤 4.5 (如果适用): UI变更的视觉验证**
如果你的代码变更涉及任何用户可见的界面（GUI、Web界面、命令行输出、生成的图像或图表等），你**必须**遵循以下的“视觉证据”协议，以确保变更的正确性：

1.  **分析项目类型与技术栈**
    你**必须**首先分析当前项目的具体技术栈，以确定最合适的界面“快照”方法。
    *   **对于Web应用**: 你应优先考虑使用浏览器自动化工具（如`Playwright`或`Selenium`）来启动一个本地服务器，并对相关的Web页面进行截图。
    *   **对于桌面GUI应用** (如PyQt, Tkinter): 你应启动应用，并使用操作系统级别的截图工具或特定库（如`Pillow`的`ImageGrab`）来捕捉应用窗口的图像。
    *   **对于命令行应用 (CLI)**: 你应运行该命令，并将完整的、包含颜色和格式的文本输出重定向到一个临时的文本文件中。这本质上是一种“文本截图”。
    *   **对于生成图像/图表的应用** (如`matplotlib`): 你应修改代码，将最终生成的图像直接保存到一个临时的图像文件中。

2.  **编写临时验证脚本**
    基于你的分析，你**必须**编写一个临时的、可自动执行的验证脚本（例如 `tmp_validate_ui.py`）。这个脚本的唯一目的，就是在隔离的环境中重现UI的变更。

3.  **生成“视觉证据”**
    运行你的验证脚本，生成一份或多份临时的“视觉证据”文件（例如 `temp_screenshot.png`, `temp_cli_output.txt`, `temp_chart.jpg`）。这些文件**必须**被保存在一个被`.gitignore`忽略的临时目录中。

4.  **强制性的本地验证**
    在进入下一步之前，你**必须**在心中回答以下问题，如同进行一次自我审查：
    *   “这份‘视觉证据’是否清晰、完整地展示了我的UI变更？”
    *   “变更后的UI是否与`spec`文档或Issue中描述的预期完全一致？”
    *   “我是否引入了任何意料之外的视觉回归（例如，布局错位、颜色错误、文本截断）？”
    只有当你对所有这些问题的答案都是肯定的，你才能继续。

5.  **提交前清理**
    在提交代码（`git commit`）之前，你**必须删除**所有临时的验证脚本和生成的“视觉证据”文件，保持项目仓库的整洁。

#### **步骤 5：本地完整验证**
在发起 Pull Request **之前**，你**必须**在本地完整地运行并通过以下所有命令，确保你的代码在集成环境中是完全健康的：
```bash
bash .codecraft/scripts/build.sh
```
这个命令会执行包括**测试覆盖率检查 (`pytest --cov`)** 和**静态类型检查 (`mypy`)** 在内的所有质量门槛。

---

*   **人类开发者**: 虽然此工作流是为AI设计的，但强烈建议人类开发者也遵循这些原则，以共同维护项目的最高质量标准。
*   **团队知识库**: 对于核心依赖，任何团队成员都可以选择性地使用 `python .codecraft/scripts/generate_api_docs.py <library_name>` 来构建一份永久的、共享的API文档。

## 7. Code-Based 项目工作流

我们采用一种创新的、完全基于代码和Git的协作模式。这套系统取代了所有外部项目管理工具（如Jira），使得项目的每一个环节——从设计、任务分配到决策——都变得透明、可追溯和可审查。

**如果你是新手，请先阅读 `project_docs/help/` 里的快速上手指南！**

### **核心理念**

*   **目录即状态**: 一个文件所在的目录，就代表了它的当前状态（例如，`tasks/in_progress/`）。
*   **`git mv`即状态变更**: 我们通过执行 `git mv` 命令来更新任务状态。这个操作必须与相关代码一起提交。
*   **万物皆代码**: 任务、设计、规范、日志，所有的一切都是项目仓库中的文件。

### **五大核心目录**

1.  **`/tasks/`**: **任务看板**。存放所有开发任务。
    *   `backlog/`: 待办列表。
    *   `todo/`: 计划处理。
    *   `in_progress/`: 正在开发中。
    *   `done/`: 已完成。
2.  **`/specs/`**: **设计与规范**。存放所有功能的详细设计文档 (Spec)。
3.  **`/project_docs/`**: **项目文档**。存放你自己的、项目特定的文档，例如 **设计脑图**、架构图和 **帮助文档** (`help/`)。
4.  **`/project_logs/`**: **沟通与决策日志**。用于记录与AI和团队的讨论摘要。
5.  **`/.codecraft/adr/`**: **架构决策记录 (ADR)**。存放对项目有长远影响的重大技术决策。

### **标准开发流程 (示例：开发一个“用户登录”功能)**

#### **阶段一：规划与设计 (Planning & Design)**

1.  **创建任务**: 在 `tasks/backlog/` 目录下创建一个新任务文件，例如 `add-user-login-feature.md`。
2.  **设计脑图 (可选，但推荐)**:
    *   复制 `.codecraft/templates/mindmap_template.md` 到 `project_docs/`。
    *   重命名为 `user-login-mindmap.md`。
    *   通过脑图梳理功能的整体结构。
3.  **编写规范 (Spec)**:
    *   复制 `specs/template.md` 到 `specs/`。
    *   重命名为 `spec-user-login.md`。
    *   在 Spec 中详细描述功能的背景、目标、技术方案等。
4.  **评审与沟通**:
    *   与团队成员或AI讨论你的设计方案和Spec。
    *   将关键的讨论结论，记录到 `project_logs/team_discussions.md` 或 `ai_interactions.md` 中。
5.  **任务就绪**: 当 Spec 清晰无误后，将任务文件移至 `tasks/todo/`。
    ```bash
    git mv tasks/backlog/add-user-login-feature.md tasks/todo/
    ```

#### **阶段二：开发与提交 (Development & Submission)**

1.  **开始任务**:
    *   创建一个新的功能分支: `git checkout -b feat/user-login`。
    *   将任务文件移至 `in_progress/`，并将此操作作为你分支的**第一个 commit**。
    ```bash
    git mv tasks/todo/add-user-login-feature.md tasks/in_progress/
    git commit -m "chore: Start work on user login feature"
    ```
2.  **编码**: 遵循 **AI的强制性开发工作流** (见上一节) 进行编码和单元测试。
3.  **创建PR**:
    *   当功能完成后，创建一个 Pull Request。
    *   在 PR 的描述中，**必须** 链接到相关的 Task 和 Spec 文件。
    ```markdown
    ### Description
    This PR implements the user login feature.

    **Related Documents:**
    - **Task:** `tasks/in_progress/add-user-login-feature.md`
    - **Spec:** `specs/spec-user-login.md`
    ```

#### **阶段三：完成 (Completion)**

1.  **合并PR**: 在代码审查通过后，将 PR 合并到 `main` 分支。
2.  **标记完成**: 创建一个最后的小提交，将任务文件移至 `done/`。
    ```bash
    git mv tasks/in_progress/add-user-login-feature.md tasks/done/
    git commit -m "chore: Mark user login feature as done"
    ```
    这个提交可以直接推送到 `main` 分支。

通过这套流程，我们的每一次变更都有着清晰、完整、可追溯的上下文记录。


## 9. 代码注释

*   **解释“为什么”，而不是“做什么”**。
*   为复杂的业务逻辑、算法或需要注意的陷阱添加注释。
*   使用 `# TODO:` 或 `# FIXME:` 来标记技术债。

## 10. 构建与发布

我们拥有一个与云端 CI/CD 流程对齐的本地构建脚本，以确保所有开发者都能在本地验证构建的完整性。

### 本地构建

在推送代码或发起 Pull Request 之前，**必须**运行本地构建脚本并通过所有检查：

```bash
bash .codecraft/scripts/build.sh
```
这个脚本是最终的质量门槛，它会自动执行包括依赖检查、测试、测试覆盖率检查、静态类型检查、文档生成和打包在内的所有关键步骤。

### 官方发布

项目的官方发布流程是自动化的，通过 GitHub Actions 实现。当一个版本标签（如 `v1.2.0`）被推送到 `main` 分支时，CI/CD 流程会自动触发，构建所有产出物（Python包、文档网站），并创建一个新的 GitHub Release。

## 10. 更新项目文档

本项目遵循“文档即代码 (Docs-as-Code)”的哲学。这意味着，对任何文档的修改，都应遵循与修改代码**完全相同**的严格流程。

1.  **创建 Issue**: 提出一个修改文档的建议，并解释“为什么”需要修改。
2.  **创建分支**: 遵循 `docs/<description>` 的分支命名规范。
3.  **修改文档**: 进行实际的修改。
4.  **发起 Pull Request**: 提交 PR，并清晰地说明文档的变更内容。
5.  **同行审查 (Peer Review)**: 文档的修改也需要至少一位其他团队成员的审查和批准。

感谢你的贡献！
