# 贡献指南 (Contribution Guidelines)

欢迎你为 CodeCraftAI 项目贡献代码或文档！本指南旨在帮助每一位成员高效协作，并共同维护项目的长期健康。

## 1. 项目理念

我们不仅仅是在构建一个项目，更是在实践一套高效、透明、可追溯的开发哲学。我们建立的所有规范（Spec、ADR、Git工作流等）都是为了服务于以下核心目标：

*   **清晰优于聪明**: 我们更倾向于清晰、可读的代码和文档，而不是难以理解的“聪明”技巧。
*   **决策可追溯**: 任何重要的技术决策都应该被记录下来，以便未来的我们能够理解当时“为什么”这样做。
*   **自动化保障质量**: 我们相信应该让工具来做重复性的、易错的检查工作，让人类专注于创造性的、有价值的思考。
*   **文档驱动开发**: 我们在编码前思考和写作，确保我们在正确的方向上努力。

## 2. 我们的工具链

为了实现上述理念，我们采用了一套精心挑选的、行业标准的工具链。了解它们的作用将帮助你更好地为项目做贡献。

*   **`pytest`**: Python 的黄金标准测试框架。我们用它来保证代码的正确性和健壮性。
*   **`black`**: “不妥协”的代码格式化工具。它能终结所有关于代码风格的争论，让所有代码看起来都像一个人写的。
*   **`ruff`**: 极速的 Python Linter。它能在瞬间扫描代码，发现从简单语法错误到复杂逻辑缺陷的数百种问题。
*   **`pre-commit`**: Git 钩子管理器。它是我们的自动化质量守卫，在每次你提交代码时，它都会自动运行 `black` 和 `ruff`，确保不符合质量标准的代码无法进入我们的代码库。
*   **`pip-tools`**: 依赖管理工具。我们用它将 `pyproject.toml` 中定义的高级依赖，编译成包含精确版本号的 `requirements.txt` 文件，以确保环境的绝对可复现性。

## 3. 沟通语言

为了方便当前团队的沟通，我们约定所有公开的交流和文档编写均使用 **中文**。这包括 Git 提交信息、Pull Request、代码注释、规范文档等。

*注：随着项目的发展和国际化，未来可能会转为使用英语。*

## 4. 进度同步与任务管理

我们使用 **GitHub Issues** 和 **Project Boards** 来实现开发进度的透明化管理。

1.  **一切始于 Issue**: 任何开发任务（新功能、Bug修复、重构等）都应该从创建一个 Issue 开始。请使用我们提供的 [Issue 模板](/.github/ISSUE_TEMPLATE) 来确保信息的完整性。
2.  **认领任务**: 当你准备开始一个任务时，请将自己分配（Assign）给对应的 Issue。
3.  **使用看板**: 项目维护者会将 Issue 添加到项目看板中。请在开发过程中，及时将代表你任务的卡片在看板的不同列（如 `待办` -> `进行中` -> `待审查`）之间移动。
4.  **关联 PR**: 当你提交 Pull Request 时，请在描述中链接到对应的 Issue (例如 `Closes #42`)，这样当 PR 被合并后，相关的 Issue 将被自动关闭。

## 5. Git 工作流规范

我们遵循一个结构化的 Git 工作流，以保持版本历史的清晰和可追溯性。

### 分支命名

所有分支都应从 `main` 分支创建，并遵循 `类型/简短描述` 的格式（示例: `feat/real-time-debugging`, `fix/login-bug`）。详细的 `<类型>` 列表请见下文。

### 提交信息 (Commit Messages)

我们采用 **Conventional Commits** 规范。格式为 `<类型>[可选的作用域]: <描述>`。

**`<类型>`** 必须是以下之一：
*   **feat**: 新功能
*   **fix**: Bug 修复
*   **docs**: 文档变更
*   **style**: 代码风格
*   **refactor**: 代码重构
*   **test**: 增加或修改测试
*   **chore**: 构建过程或辅助工具的变动

## 6. AI的强制性开发工作流

为杜绝低级错误并确保每一行代码都符合最高的质量标准，所有AI开发者**必须**严格遵循以下包含三个阶段、五个步骤的开发工作流。这不仅是一份指南，更是AI行为的核心准则。

### **第一阶段：API与引用验证 (编码前)**

#### **步骤 1：主动探索与临时笔记**
在你编写任何正式代码**之前**，你**必须**对所有即将引用的外部库、内部模块或函数进行主动探索。

1.  **编写探索脚本**: 创建一个临时的探索脚本 (例如, `tmp_explore_api.py`)。
2.  **分析API**: 在脚本中使用 Python 的内建函数 `dir()` 和 `help()` 来系统性地检查目标库的可用 API、函数签名、参数、返回值和文档字符串。
3.  **创建临时笔记**: 将探索得到的关键信息整理成一个临时的 Markdown 笔记文件 (例如, `temp_api_notes.md`)。这份笔记是你后续编码的**唯一真理之源**。

### **第二阶段：编码与即时自检 (编码中)**

#### **步骤 2：依据笔记编码**
你**必须**严格依据你在第一阶段创建的临时笔记进行编码，以确保所有的函数调用和变量引用都是准确无误的。

#### **步骤 3：启动“守护进程”**
在开始编码时，你**必须**在一个单独的终端中启动实时开发助手：
```bash
python scripts/guardian.py
```
这个“守护进程”会在你每次保存文件时，立即在后台为你运行代码检查 (`ruff`, `black`)、静态类型检查 (`mypy`) 和单元测试 (`pytest`)，提供即时的质量反馈。

### **第三阶段：严格的单元测试与最终验证 (编码后，提交前)**

#### **步骤 4：编写全面的单元测试**
对于你所编写的**每一个**新功能或修复，你**必须**为其编写一套全面的单元测试。这套测试**必须**覆盖以下场景：

*   **成功场景 (Happy Path)**: 验证功能在正常输入下按预期工作。
*   **失败场景 (Unhappy Path)**:
    *   **无效输入**: 测试函数在接收到 `None`、空字符串、错误类型或超出范围的数值时的行为。
    *   **边界值**: 测试边缘情况，例如列表为空、数值为0等。
    *   **预期异常**: 测试代码是否能在预期的失败情况下（例如，文件不存在）抛出正确的异常（例如 `FileNotFoundError`）。
*   **模拟 (Mocking)**: 如果你的代码引用了任何外部依赖（文件系统、数据库、网络API等），你**必须**使用 Python 的 `unittest.mock` 库来模拟这些依赖的各种行为（成功、失败、超时、返回空数据等），以确保你的代码能够优雅地处理所有外部情况。

#### **步骤 4.5 (如果适用): UI变更的视觉验证**
如果你的代码变更涉及任何用户可见的界面（GUI、Web界面、命令行输出、生成的图像或图表等），你**必须**遵循以下的“视觉证据”协议，以确保变更的正确性：

1.  **分析项目类型与技术栈**
    你**必须**首先分析当前项目的具体技术栈，以确定最合适的界面“快照”方法。
    *   **对于Web应用**: 你应优先考虑使用浏览器自动化工具（如`Playwright`或`Selenium`）来启动一个本地服务器，并对相关的Web页面进行截图。
    *   **对于桌面GUI应用** (如PyQt, Tkinter): 你应启动应用，并使用操作系统级别的截图工具或特定库（如`Pillow`的`ImageGrab`）来捕捉应用窗口的图像。
    *   **对于命令行应用 (CLI)**: 你应运行该命令，并将完整的、包含颜色和格式的文本输出重定向到一个临时的文本文件中。这本质上是一种“文本截图”。
    *   **对于生成图像/图表的应用** (如`matplotlib`): 你应修改代码，将最终生成的图像直接保存到一个临时的图像文件中。

2.  **编写临时验证脚本**
    基于你的分析，你**必须**编写一个临时的、可自动执行的验证脚本（例如 `tmp_validate_ui.py`）。这个脚本的唯一目的，就是在隔离的环境中重现UI的变更。

3.  **生成“视觉证据”**
    运行你的验证脚本，生成一份或多份临时的“视觉证据”文件（例如 `temp_screenshot.png`, `temp_cli_output.txt`, `temp_chart.jpg`）。这些文件**必须**被保存在一个被`.gitignore`忽略的临时目录中。

4.  **强制性的本地验证**
    在进入下一步之前，你**必须**在心中回答以下问题，如同进行一次自我审查：
    *   “这份‘视觉证据’是否清晰、完整地展示了我的UI变更？”
    *   “变更后的UI是否与`spec`文档或Issue中描述的预期完全一致？”
    *   “我是否引入了任何意料之外的视觉回归（例如，布局错位、颜色错误、文本截断）？”
    只有当你对所有这些问题的答案都是肯定的，你才能继续。

5.  **提交前清理**
    在提交代码（`git commit`）之前，你**必须删除**所有临时的验证脚本和生成的“视觉证据”文件，保持项目仓库的整洁。

#### **步骤 5：本地完整验证**
在发起 Pull Request **之前**，你**必须**在本地完整地运行并通过以下所有命令，确保你的代码在集成环境中是完全健康的：
```bash
bash scripts/build.sh
```
这个命令会执行包括**测试覆盖率检查 (`pytest --cov`)** 和**静态类型检查 (`mypy`)** 在内的所有质量门槛。

---

*   **人类开发者**: 虽然此工作流是为AI设计的，但强烈建议人类开发者也遵循这些原则，以共同维护项目的最高质量标准。
*   **团队知识库**: 对于核心依赖，任何团队成员都可以选择性地使用 `python scripts/generate_api_docs.py <library_name>` 来构建一份永久的、共享的API文档。

## 7. 决策记录

*   **规范 (Specs)**: 所有对用户可见或对系统有重要影响的变更，都必须先编写一份规范文档。
*   **架构决策记录 (ADRs)**: 当一项规范的讨论中产生了对项目有长远影响的重要技术决策时（例如，选择一个特定的数据库、定义一个核心的API范式等），应将其沉淀为一份ADR文档，存放在 `adr/` 目录中。
*   **AI 协作记录**: 我们与 AI 助手的关键决策性对话摘要，会存放在 `adr/ai-sessions/` 目录中，作为项目历史的一部分。

## 8. 代码注释

*   **解释“为什么”，而不是“做什么”**。
*   为复杂的业务逻辑、算法或需要注意的陷阱添加注释。
*   使用 `# TODO:` 或 `# FIXME:` 来标记技术债。

## 9. 构建与发布

我们拥有一个与云端 CI/CD 流程对齐的本地构建脚本，以确保所有开发者都能在本地验证构建的完整性。

### 本地构建

在推送代码或发起 Pull Request 之前，**必须**运行本地构建脚本并通过所有检查：

```bash
bash scripts/build.sh
```
这个脚本是最终的质量门槛，它会自动执行包括依赖检查、测试、测试覆盖率检查、静态类型检查、文档生成和打包在内的所有关键步骤。

### 官方发布

项目的官方发布流程是自动化的，通过 GitHub Actions 实现。当一个版本标签（如 `v1.2.0`）被推送到 `main` 分支时，CI/CD 流程会自动触发，构建所有产出物（Python包、文档网站），并创建一个新的 GitHub Release。

## 10. 更新项目文档

本项目遵循“文档即代码 (Docs-as-Code)”的哲学。这意味着，对任何文档的修改，都应遵循与修改代码**完全相同**的严格流程。

1.  **创建 Issue**: 提出一个修改文档的建议，并解释“为什么”需要修改。
2.  **创建分支**: 遵循 `docs/<description>` 的分支命名规范。
3.  **修改文档**: 进行实际的修改。
4.  **发起 Pull Request**: 提交 PR，并清晰地说明文档的变更内容。
5.  **同行审查 (Peer Review)**: 文档的修改也需要至少一位其他团队成员的审查和批准。

感谢你的贡献！
